generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/// Per-user custom profile page settings
model UserProfile {
  userId       String   @id
  subdomain    String?  @unique
  pageTitle    String?  @default("My Page")
  bio          String?
  bgType       String?
  bgValue      String?
  audioUrl     String?
  customAvatar String?
  customBanner String?
  youtubeUrl   String?
  instagramUrl String?
  discordUrl   String?
  theme        String?  @default("default")
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id               String                @id @default(cuid())
  email            String                @unique
  username         String                @unique
  displayName      String
  password         String
  avatar           String?
  banner           String?
  status           String                @default("online")
  description      String?
  /// Global appearance preferences
  theme            String                @default("default")
  chatBgUrl        String?
  chatBgOpacity    Int                   @default(30)
  effectEnabled    Boolean               @default(true)
  effectOpacity    Int                   @default(60)
  isAdmin          Boolean               @default(false)
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  avatarDecoration String?
  /// Optional: which server's tag/badge the user chooses to display globally
  badgeServerId    String?
  accounts         Account[]
  aiConversations  AiConversation[]
  createdInvites   Invite[]              @relation("InviteCreator")
  messages         Message[]
  reactionUsers    MessageReactionUser[]
  messageViews     MessageView[]
  pollVotes        PollVote[]
  ownedServers     Server[]              @relation("ServerOwner")
  bansIssued       ServerBan[]           @relation("UserBanner")
  bansReceived     ServerBan[]           @relation("UserBanned")
  servers          ServerMember[]
  sessions         Session[]
  badgeServer      Server?               @relation("UserBadgeServer", fields: [badgeServerId], references: [id])
  profile          UserProfile?
  // Byte relations
  memberships      UserMembership[]
  boosts           UserBoost[]
  panelsOwned      Panel[]               @relation("UserPanels")
  pteroCredentials PteroCredential[]
  // Blog relations
  blogPosts        BlogPost[]
  blogComments     BlogComment[]
  blogReactions    BlogReaction[]
  blogCommentReactions BlogCommentReaction[]
  // Profile and decoration relations
  decorations      UserDecoration[]
  uploads          Upload[]         @relation("UserUploads")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Server {
  id                   String         @id @default(cuid())
  name                 String
  description          String?
  icon                 String?
  banner               String?
  tag                  String?
  byteeLevel           Int            @default(0)
  isDefault            Boolean        @default(false)
  /// Total boost level from all active boosts
  boostLevel           Int            @default(0)
  /// Active boosts applied to this server
  boosts               UserBoost[]
  ownerId              String
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  advertisementEnabled Boolean        @default(false)
  advertisementText    String?
  categories           Category[]
  channels             Channel[]
  invites              Invite[]
  owner                User           @relation("ServerOwner", fields: [ownerId], references: [id])
  bans                 ServerBan[]
  members              ServerMember[]
  roles                ServerRole[]
  badgeUsers           User[]         @relation("UserBadgeServer")
  // Byte panels per server
  panels               Panel[]
}

model ServerRole {
  id                 String              @id @default(cuid())
  name               String
  /// Legacy flat color
  color              String              @default("#99AAB5")
  /// Optional Tailwind gradient classes, e.g. "from-sky-500 to-cyan-400"
  gradient           String?
  /// Whether the gradient animates (requires server.boostLevel >= 2)
  animated           Boolean             @default(false)
  /// Optional font family name to render role labels
  font               String?
  /// JSON array of permission keys (back-compat kept via `permissions` string)
  permissions        String
  permissionsJson    String?
  serverId           String
  isDefault          Boolean             @default(false)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  channelPermissions ChannelPermission[]
  members            ServerMember[]
  memberRoles        ServerMemberRole[]
  server             Server              @relation(fields: [serverId], references: [id], onDelete: Cascade)
  // Byte: role access to panels
  panelAccess        PanelRoleAccess[]
}

model ServerMember {
  id           String             @id @default(cuid())
  userId       String
  serverId     String
  roleId       String?
  role         String             @default("member")
  joinedAt     DateTime           @default(now())
  mutedUntil   DateTime?
  timeoutUntil DateTime?
  serverRole   ServerRole?        @relation(fields: [roleId], references: [id])
  server       Server             @relation(fields: [serverId], references: [id], onDelete: Cascade)
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  roles        ServerMemberRole[]
}

/// New: M2M table to assign multiple roles to a member (explicit relation to ServerMember)
model ServerMemberRole {
  id        String       @id @default(cuid())
  memberId  String
  roleId    String
  createdAt DateTime     @default(now())
  role      ServerRole   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  member    ServerMember @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([memberId, roleId])
}

/// Records server bans. A user may have at most one active ban per server.
model ServerBan {
  id         String    @id @default(cuid())
  serverId   String
  userId     String
  bannedBy   String
  reason     String?
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  banner     User      @relation("UserBanner", fields: [bannedBy], references: [id], onDelete: Cascade)
  bannedUser User      @relation("UserBanned", fields: [userId], references: [id], onDelete: Cascade)
  server     Server    @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@unique([serverId, userId], name: "serverId_userId")
}

model Category {
  id        String            @id @default(cuid())
  name      String
  emoji     String?
  font      String?
  serverId  String
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  /// For UI ordering in server settings
  position  Int               @default(0)
  server    Server            @relation(fields: [serverId], references: [id], onDelete: Cascade)
  override  CategoryOverride?
  channels  Channel[]
}

model Channel {
  id              String              @id @default(cuid())
  name            String
  type            String              @default("text")
  categoryId      String
  serverId        String
  isPrivate       Boolean             @default(false)
  topic           String?
  slowMode        Int                 @default(0)
  /// For UI ordering in server settings
  position        Int                 @default(0)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  customBg        String?
  bgOpacity       Int                 @default(100)
  textColor       String?
  accentColor     String?
  gradientFrom    String?
  gradientTo      String?
  useGradient     Boolean             @default(false)
  backgroundType  String?
  backgroundUrl   String?
  backgroundColor String?
  /// Display styling for channel name
  nameColor       String?
  nameGradient    String?
  nameAnimation   String?
  /// Optional font key used by the UI
  font            String?
  category        Category            @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  server          Server              @relation(fields: [serverId], references: [id], onDelete: Cascade)
  appearance      ChannelAppearance?
  permissions     ChannelPermission[]
  messages        Message[]
  polls           Poll[]
  // Byte panel channel link(s)
  panels         Panel[]
}

model ChannelPermission {
  id              String      @id @default(cuid())
  channelId       String
  roleId          String?
  userId          String?
  /// Back-compat single permission string (deprecated)
  permission      String
  /// Structured permissions (preferred)
  canView         Boolean     @default(true)
  canRead         Boolean     @default(true)
  canSend         Boolean     @default(true)
  canEdit         Boolean     @default(false)
  canManage       Boolean     @default(false)
  canDeleteOthers Boolean     @default(false)
  canReact        Boolean     @default(true)
  canSendGifs     Boolean     @default(true)
  createdAt       DateTime    @default(now())
  roleRef         ServerRole? @relation(fields: [roleId], references: [id], onDelete: Cascade)
  channel         Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId, roleId, userId, permission])
}

model Message {
  id          String            @id @default(cuid())
  content     String
  userId      String
  channelId   String
  replyToId   String?
  mentions    String
  attachments String
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  /// Soft delete: when true, message is hidden from clients
  deleted     Boolean           @default(false)
  replyTo     Message?          @relation("MessageReplies", fields: [replyToId], references: [id])
  replies     Message[]         @relation("MessageReplies")
  channel     Channel           @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  reactions   MessageReaction[]
  viewedBy    MessageView[]
}

model MessageView {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  viewedAt  DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
}

model MessageReaction {
  id        String                @id @default(cuid())
  messageId String
  emoji     String
  createdAt DateTime              @default(now())
  message   Message               @relation(fields: [messageId], references: [id], onDelete: Cascade)
  users     MessageReactionUser[]
}

model MessageReactionUser {
  id         String          @id @default(cuid())
  reactionId String
  userId     String
  createdAt  DateTime        @default(now())
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  reaction   MessageReaction @relation(fields: [reactionId], references: [id], onDelete: Cascade)

  @@unique([reactionId, userId])
}

model Invite {
  id        String    @id @default(cuid())
  code      String    @unique
  serverId  String
  createdBy String
  expiresAt DateTime?
  maxUses   Int?
  uses      Int       @default(0)
  createdAt DateTime  @default(now())
  creator   User      @relation("InviteCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  server    Server    @relation(fields: [serverId], references: [id], onDelete: Cascade)
}

/// AI Conversations for per-user chat memory and code generation
model AiConversation {
  id        String      @id @default(cuid())
  userId    String
  title     String      @default("New AI Chat")
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  assets    AiAsset[]
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  AiMessage[]

  @@index([userId, createdAt])
}

model AiMessage {
  id             String         @id @default(cuid())
  conversationId String
  role           String
  content        String
  codeHtml       String?
  codeCss        String?
  codeJs         String?
  createdAt      DateTime       @default(now())
  conversation   AiConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

model AiAsset {
  id             String         @id @default(cuid())
  conversationId String
  name           String
  contentType    String?
  content        String?
  url            String?
  createdAt      DateTime       @default(now())
  conversation   AiConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
}

/// New: Per-channel appearance (DB-first, replaces JSON/localStorage)
model ChannelAppearance {
  channelId       String   @id
  backgroundColor String?
  backgroundImage String?
  backgroundVideo String?
  textColor       String?
  fontFamily      String?
  fontSize        Int?
  customCSS       String?
  isPrivate       Boolean? @default(false)
  slowMode        Int?     @default(0)
  updatedBy       String?
  updatedAt       DateTime @updatedAt
  channel         Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
}

/// New: Per-category overrides (rename/delete)
model CategoryOverride {
  categoryId String   @id
  name       String?
  deleted    Boolean  @default(false)
  updatedBy  String?
  updatedAt  DateTime @updatedAt
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
}

/// Byte membership tiers (e.g., Byte = Nitro-like)
model MembershipTier {
  id          String   @id @default(cuid())
  name        String   @unique
  priceInINR  Int
  priceInUSD  Float
  description String?
  featuresJson String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  memberships UserMembership[]
}

/// User's active/canceled membership
model UserMembership {
  id           String          @id @default(cuid())
  userId       String
  tierId       String
  status       String          @default("active") // active|canceled|expired
  startedAt    DateTime        @default(now())
  expiresAt    DateTime?
  metadataJson String?         // Store additional data like granted boosts
  boostsGranted Boolean        @default(false) // Whether initial boosts have been granted
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier         MembershipTier  @relation(fields: [tierId], references: [id], onDelete: Cascade)
  boosts       UserBoost[]

  @@index([userId, status])
}

/// Tracks boosts that users can apply to servers
model UserBoost {
  id           String          @id @default(cuid())
  userId       String
  membershipId String
  serverId     String?         // null means unassigned boost
  value        Int             @default(1) // Boost value (1 = 10 rupees)
  isActive     Boolean         @default(true)
  expiresAt    DateTime?       // When the boost expires (if temporary)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  membership   UserMembership  @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  server       Server?         @relation(fields: [serverId], references: [id])
  
  @@index([userId, isActive])
  @@index([serverId, isActive])
}

/// Owner's private panel definition per server
model Panel {
  id        String   @id @default(cuid())
  ownerId   String
  serverId  String
  channelId String
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner     User     @relation("UserPanels", fields: [ownerId], references: [id], onDelete: Cascade)
  server    Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  channel   Channel  @relation(fields: [channelId], references: [id], onDelete: Cascade)
  access    PanelRoleAccess[]
  creds     PteroCredential[]

  @@index([serverId, ownerId])
}

/// Role-based access for a panel
model PanelRoleAccess {
  id       String     @id @default(cuid())
  panelId  String
  roleId   String
  canView  Boolean    @default(true)
  canManage Boolean   @default(false)
  panel    Panel      @relation(fields: [panelId], references: [id], onDelete: Cascade)
  role     ServerRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([panelId, roleId])
}

/// Owner's Pterodactyl credentials for a panel
model PteroCredential {
  id         String   @id @default(cuid())
  panelId    String
  ownerId    String
  baseUrl    String
  adminApiKey String?
  clientApiKey String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  panel      Panel    @relation(fields: [panelId], references: [id], onDelete: Cascade)
  owner      User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([panelId, ownerId])
}

/// New: Polls (message-linked via channelId; options and votes track users)
model Poll {
  id          String       @id @default(cuid())
  channelId   String
  question    String
  multiSelect Boolean      @default(false)
  createdBy   String
  createdAt   DateTime     @default(now())
  channel     Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  options     PollOption[]
  votes       PollVote[]

  @@index([channelId, createdAt])
}

model PollOption {
  id     String     @id @default(cuid())
  pollId String
  label  String
  index  Int
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  PollVote[]

  @@index([pollId, index])
}

model PollVote {
  id        String     @id @default(cuid())
  pollId    String
  optionId  String
  userId    String
  createdAt DateTime   @default(now())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  option    PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  poll      Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId, optionId])
  @@index([pollId, userId])
}

/// Blog system models
model BlogPost {
  id            String          @id @default(cuid())
  title         String
  slug          String          @unique
  excerpt       String?
  content       String          // Rich HTML content
  coverImage    String?         // Main cover image URL
  authorId      String
  categoryId    String?
  status        BlogPostStatus  @default(DRAFT)
  featured      Boolean         @default(false)
  readTime      Int?            // Estimated read time in minutes
  views         Int             @default(0)
  likes         Int             @default(0)
  publishedAt   DateTime?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  // SEO fields
  metaTitle     String?
  metaDescription String?
  
  // Custom styling
  customCSS     String?
  fontFamily    String?
  textColor     String?
  backgroundColor String?
  
  author        User            @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category      BlogCategory?   @relation(fields: [categoryId], references: [id])
  tags          BlogPostTag[]
  media         BlogMedia[]
  comments      BlogComment[]
  reactions     BlogReaction[]
  
  @@index([status, publishedAt])
  @@index([authorId])
  @@index([featured, publishedAt])
}

model BlogCategory {
  id          String     @id @default(cuid())
  name        String     @unique
  slug        String     @unique
  description String?
  color       String?    // Hex color for category
  icon        String?    // Icon name or emoji
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  
  posts       BlogPost[]
}

model BlogTag {
  id        String        @id @default(cuid())
  name      String        @unique
  slug      String        @unique
  color     String?       // Hex color for tag
  createdAt DateTime      @default(now())
  
  posts     BlogPostTag[]
}

model BlogPostTag {
  id     String   @id @default(cuid())
  postId String
  tagId  String
  
  post   BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    BlogTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([postId, tagId])
}

model BlogMedia {
  id          String        @id @default(cuid())
  postId      String
  type        BlogMediaType
  url         String
  filename    String
  size        Int?          // File size in bytes
  mimeType    String?
  alt         String?       // Alt text for images
  caption     String?
  width       Int?
  height      Int?
  duration    Int?          // For videos, duration in seconds
  thumbnail   String?       // Thumbnail URL for videos
  position    Int           @default(0) // Order in post
  createdAt   DateTime      @default(now())
  
  post        BlogPost      @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@index([postId, position])
}

model BlogComment {
  id        String         @id @default(cuid())
  postId    String
  authorId  String
  content   String
  parentId  String?        // For nested comments
  status    CommentStatus  @default(APPROVED)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  
  post      BlogPost       @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    BlogComment?   @relation("CommentReplies", fields: [parentId], references: [id])
  replies   BlogComment[]  @relation("CommentReplies")
  reactions BlogCommentReaction[]
  
  @@index([postId, status, createdAt])
}

model BlogReaction {
  id        String      @id @default(cuid())
  postId    String
  userId    String
  type      ReactionType
  createdAt DateTime    @default(now())
  
  post      BlogPost    @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([postId, userId, type])
}

model BlogCommentReaction {
  id        String      @id @default(cuid())
  commentId String
  userId    String
  type      ReactionType
  createdAt DateTime    @default(now())
  
  comment   BlogComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([commentId, userId, type])
}

// Enums for blog system
enum BlogPostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  SCHEDULED
}

enum BlogMediaType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  EMBED
}

enum CommentStatus {
  PENDING
  APPROVED
  REJECTED
  SPAM
}

enum ReactionType {
  LIKE
  LOVE
  LAUGH
  WOW
  SAD
  ANGRY
}

/// Avatar decorations available in the system
model AvatarDecoration {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  imageUrl    String   // URL to the decoration image/animation
  rarity      String   @default("common") // common, rare, epic, legendary
  price       Int?     // Price in Byte currency (null = free)
  isActive    Boolean  @default(true)
  isAnimated  Boolean  @default(false)
  category    String?  // e.g., "seasonal", "premium", "event"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Users who own this decoration
  owners      UserDecoration[]
}

/// User's owned decorations
model UserDecoration {
  id           String           @id @default(cuid())
  userId       String
  decorationId String
  purchasedAt  DateTime         @default(now())
  isEquipped   Boolean          @default(false) // Only one can be equipped at a time
  
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  decoration   AvatarDecoration @relation(fields: [decorationId], references: [id], onDelete: Cascade)
  
  @@unique([userId, decorationId])
  @@index([userId, isEquipped])
}

/// File uploads tracking
model Upload {
  id          String    @id @default(cuid())
  filename    String
  originalName String
  mimeType    String
  size        Int       // Size in bytes
  url         String    // Full URL to access the file
  uploadedBy  String
  uploadType  String    // "avatar", "banner", "decoration", "blog_media", etc.
  metadata    String?   // JSON metadata (dimensions, etc.)
  createdAt   DateTime  @default(now())
  
  uploader    User      @relation("UserUploads", fields: [uploadedBy], references: [id], onDelete: Cascade)
  
  @@index([uploadedBy, uploadType])
  @@index([createdAt])
}
